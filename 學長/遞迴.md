## 遞迴函式
遞迴函式會直接或間接呼叫自己
遞迴什麼時候會不再往下就叫終止條件

階層
```cpp
#include <iostream>
using namespace std;

int f_recur(int n){
    if (n == 0){//終止條件
        return 1;
    }else{
        return n * f_recur(n-1);
    }
}

int main() {
    int n = 0;
    cin >> n;
    cout << f_recur(n) << endl;
    return 0;
}
```
a的b次方
















#include <iostream>
using namespace std;

int p(int a, int b){
    if (b == 0){
        return 1;
    }else{
        return a * p(a, b-1);
    }
}

int main() {
    int a = 0, b = 0;
    cin >> a >> b;
    cout << p(a, b) << endl;
    return 0;
}
河內塔



















#include <iostream>
using namespace std;

void hanoi(char From, char Buff, char To, int disk){
    if (disk == 1){
        cout << "move 1 disk from " << From << " to " << To << endl;
    } else {
        hanoi(From, To, Buff, disk - 1);
        cout << "move 1 disk from " << From << " to " << To << endl;
        hanoi(Buff, From, To, disk - 1);
    }
}

int main() {
    char from, buff, to;
    int disk;
    cin >> from >> buff >> to >> disk;
    hanoi(from, buff, to, disk);
    return 0;
}
費波那契數列



















#include <iostream>
using namespace std;

int f(int n){
    if (n == 0){//終止條件
        return 0;
    }else if (n == 1){
        return 1;
    }else{
        return f(n-1)+ f(n-2);
    }
}

int main() {
    int n = 0;
    while(cin >> n){
        cout << f(n) << endl;
    }
    return 0;
}
F91


















#include <iostream>
using namespace std;

int f91(int n){
    if (n > 100){//終止條件
        return n - 10;
    }else{
        return f91(f91(n + 11));
    }
}

int main() {
    int n = 0;
    while(cin >> n){
        if (n == 0) break;
        cout << "f91(" << n << ") = " << f91(n) << endl;
    }
    return 0;
}
三色河內塔





























#include <iostream>
using namespace std;

void moveRing(int ring, char fromPeg, char toPeg) {
    cout << "ring " << ring << " : " << fromPeg << " => " << toPeg << endl;
}

void move(int n, char from, char to, char by, int& moveCount){
    if (n <= 0) return;
    move(n-1, from, by, to, moveCount);
    moveRing(n, from, to);
    moveCount++;
    move(n-1, by, to, from, moveCount);
}
void solveHanoi(int n, char fromPeg, char toPeg, char auxPeg, int& moveCount) {
    if (n <= 0) return;
    move(n - 1, fromPeg, auxPeg, toPeg, moveCount);
    moveRing(n, fromPeg, toPeg);
    moveCount++;
    solveHanoi(n - 2, auxPeg, fromPeg, toPeg, moveCount);
}

int main() {
    int n;
    cin >> n;
    int moveCount = 0;
    solveHanoi(n, 'A', 'C', 'B', moveCount);
    cout << "共需" << moveCount << "個移動" << endl;
    return 0;
}
2^k與四個自然數平方和
法(一): 會Killed










































#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

void findSquareSums(int k) {
    int target = 1 << k; // 2^k
    vector<vector<int>> solutions;

    for (int a = 1; a <= sqrt(target); ++a) {
        for (int b = a; b <= sqrt(target); ++b) {
            for (int c = b; c <= sqrt(target); ++c) {
                for (int d = c; d <= sqrt(target); ++d) {
                    if (a * a + b * b + c * c + d * d == target) {
                        solutions.push_back({a, b, c, d});
                    }
                }
            }
        }
    }

    if (!solutions.empty()) {
        for (const auto &solution : solutions) {
            for (size_t i = 0; i < solution.size(); ++i) {
                if (i != 0) cout << " ";
                cout << solution[i];
            }
            cout << endl;
        }
    } else {
        cout << 0 << endl;
    }
}

int main() {
    int k;
    cin >> k;
    findSquareSums(k);
    return 0;
}
法(二):






































#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

int num[4] = {};
int sq[65536] = {};

void find(int re, int id) {
    if (id == 3) {
        int co = sqrt(re);
        if (co * co == re) {
            cout << num[0] << " " << num[1] << " " << num[2] << " " << co << endl;
        }
        return;
    }
    int ubound, lbound;
    lbound = (id > 0) ? num[id - 1] : 1;
    ubound = sqrt(re / (4 - id));
    for (int i = lbound; i <= ubound; i++) {
        num[id] = i;
        find(re - sq[i], id + 1);
    }
}

int main() {
    int k;
    for (int i = 0; i < 65536; i++) {
        sq[i] = i * i;
    }
    cin >> k;
    if(k % 2 == 1) cout << "0" << endl;
    int target = pow(2, k);
    find(target, 0);
    return 0;
}
執行路徑數
















































#include <iostream>
#include <vector>
#include <string>
using namespace std;

long long ca(vector<string>& lines, int& index) {
    long long paths = 1;

    while (index < lines.size()) {
        if (lines[index] == "IF") {
            index++;
            int ifPaths = ca(lines, index);
            index++;
            int elsePaths = ca(lines, index);
            paths *= (ifPaths + elsePaths);
            if (index < lines.size() && lines[index] == "END_IF") {
                index++;
            }
        } else if (lines[index] == "ELSE") {
            break;
        } else if (lines[index] == "END_IF") {
            break;
        } else {
            index++;
        }
    }

    return paths;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin >> n;
    for (int p = 0; p < n; ++p) {
        vector<string> lines;
        string line;
        while (cin >> line) {
            if(line == "ENDPROGRAM") break;
            lines.push_back(line);
        }
        int index = 0;
        cout << ca(lines, index) << endl;
    }

    return 0;
}
